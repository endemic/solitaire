<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Dragging Demo</title>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body { text-align: center; }

    #game {
      margin: auto;
      background-color: #0a5;
      max-width: 100%;
      max-height: 100%;
      /* TODO: this doesn't seem to work on an actual phone */
      aspect-ratio: 4 / 3;
      cursor: grab;
    }
  </style>

  <script src="scripts/shuffle.js"></script>

  <script>
    const SUITES = ['hearts', 'diamonds', 'spades', 'clubs'];
    const RANKS = ['ace', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'jack', 'queen', 'king'];

    const IMG_SRC = [
      'images/backs/one.png',

      // 'images/hearts/ace.png',
      // 'images/hearts/two.png',
      // 'images/hearts/three.png',
      'images/hearts/four.png',
      // 'images/hearts/five.png',
      // 'images/hearts/six.png',
      // 'images/hearts/seven.png',
      // 'images/hearts/eight.png',
      // 'images/hearts/nine.png',
      // 'images/hearts/ten.png',
      // 'images/hearts/jack.png',
      // 'images/hearts/queen.png',
      // 'images/hearts/king.png',

      // 'images/diamonds/ace.png',
      // 'images/diamonds/two.png',
      // 'images/diamonds/three.png',
      // 'images/diamonds/four.png',
      // 'images/diamonds/five.png',
      // 'images/diamonds/six.png',
      // 'images/diamonds/seven.png',
      // 'images/diamonds/eight.png',
      // 'images/diamonds/nine.png',
      // 'images/diamonds/ten.png',
      // 'images/diamonds/jack.png',
      // 'images/diamonds/queen.png',
      // 'images/diamonds/king.png',

      // 'images/spades/ace.png',
      // 'images/spades/two.png',
      // 'images/spades/three.png',
      // 'images/spades/four.png',
      // 'images/spades/five.png',
      // 'images/spades/six.png',
      // 'images/spades/seven.png',
      // 'images/spades/eight.png',
      // 'images/spades/nine.png',
      // 'images/spades/ten.png',
      // 'images/spades/jack.png',
      // 'images/spades/queen.png',
      // 'images/spades/king.png',

      // 'images/clubs/ace.png',
      // 'images/clubs/two.png',
      // 'images/clubs/three.png',
      // 'images/clubs/four.png',
      // 'images/clubs/five.png',
      // 'images/clubs/six.png',
      // 'images/clubs/seven.png',
      // 'images/clubs/eight.png',
      // 'images/clubs/nine.png',
      // 'images/clubs/ten.png',
      // 'images/clubs/jack.png',
      // 'images/clubs/queen.png',
      // 'images/clubs/king.png',
    ];

    const IMAGES = {};
    let loadedImageCount = 0;

    const onImageLoad = e => {
      // TODO: display a progress bar or something
      loadedImageCount += 1;

      // this means we've got all our images in memory
      if (loadedImageCount === IMG_SRC.length) {
        // TODO: initialize the canvas before this, so a "loading" progress bar can be
        // displayed (or "Loading..." text)
        dragDemo();
      }
    }

    IMG_SRC.forEach(src => {
      // key is in format `suite_rank` -- probably a better way to do this
      let key = src.match(/(?<=images\/)\w+\/\w+/)[0].replace('/','_');

      IMAGES[key] = new Image();
      IMAGES[key].src = src;
      IMAGES[key].addEventListener('load', onImageLoad);
    });

    class Card {
      faceUp = false;
      x = 0;
      y = 0;
      backImg = null;
      frontImg = null;
      suite = null;
      rank = null;

      // TODO: figure out a way to link stacked cards together
      parent = null;
      child = null;

      constructor(rank, suite) {
        this.rank = rank;
        this.suite = suite;

        this.backImg = IMAGES['backs_one'];
        this.frontImg = IMAGES[`${this.suite}_${this.rank}`];
      }

      get image() {
        if (this.faceUp) {
          return this.frontImg;
        }

        return this.backImg;
      }
    }

    const dragDemo = e => {
      // do stuff here
      const canvas = document.getElementById('game');
      const context = canvas.getContext('2d');

      // TODO: determine the necessary max width/height based on screenshots of the old game
      // cards are 71x96px
      // margin between cards horizontally is 16px
      // margin between cards vertically is 6px

      // we could do 75x100px cards
      // 10px margin both horizontally & vertically
      // 525px total width of all cards
      // 80px (8 * 10px) horizontal margin

      // 605px max width
      // at 4:3 aspect ratio, that makes height 454px
      // is that a viable size?

      const margin = 10;
      const width = 605;
      const height = 454;
      const cardWidth = 75;
      const cardHeight = 100;
      
      // initialize all places where a card can be placed - https://en.wikipedia.org/wiki/Glossary_of_patience_terms
      
      // "talon" (draw pile)
      // placed in the upper left hand corner
      let talon = {
        x: margin,
        y: margin,
        cards: []
      };
      
      // "waste" (play stack)
      // placed relative to the talon
      let waste = {
        x: talon.x + cardWidth + margin,
        y: talon.y,
        cards: []
      };
      
      // 4 "foundations"
      // aligned vertically with talon/waste, on right side of tableau
      let foundations = [];
      for (let i = 0; i < 4; i += 1) {
        foundations.push({
          x: width - (cardWidth * (i + 1)) - (margin * (i + 1)),
          y: margin,
          cards: []
        });
      }

      // 7 "piles"
      // spans the width of the tableau, under the talon/waste/foundations
      let piles = [];
      for (let i = 0; i < 7; i += 1) {
        piles.push({
          x: cardWidth * i + (margin * (i + 1)),
          y: cardHeight + margin * 2,
          cards: []
        });
      }

      // initialize deck
      // TODO: can we re-use the list of images for this? maybe not as it includes images for card backs
      SUITES.forEach(suite => {
        RANKS.forEach(rank => {
          let card = new Card(rank, suite);

          // put all cards face down in the talon
          card.x = talon.x;
          card.y = talon.y;

          talon.cards.push(card);
        });
      });

      talon.cards.shuffle();

      const update = () => {
        context.clearRect(0, 0, width, height);

        // draw "target" backgrounds
        // TODO: extract these `drawImage` calls to specialized "drawWhatever" functions
        // which only draw the necessary cards (e.g. once a card is placed in a pile, it's no longer
        // necessary to draw the target; e.g. only draw the top card in the talon)
        context.drawImage(target, talon.x, talon.y);

        context.drawImage(target, waste.x, waste.y);
        
        foundations.forEach(position => {
          context.drawImage(target, position.x, position.y);
        });

        piles.forEach(position => {
          context.drawImage(target, position.x, position.y);
        });

        // TODO: draw cards
        // DECK.forEach(card => {
        //   context.drawImage(card.image, card.x, card.y);
        // });
      };

      // track position of the singular card we can move around
      // eventually we'd store references to all the on-screen cards
      // let card = new Card('four', 'hearts');
      // card.x = stacks[0].x;
      // card.y = stacks[0].y;

      // bool whether a card has been picked up or not
      let grabbed = null;

      // record the cursor offset where the card was picked up,
      // so clicking the card doesn't cause it to "jump" to the cursor
      let grabOffset = {x: 0, y: 0};

      // initial draw
      update();

      // rudimentary bounding box intersection
      // TODO: make this a check to see if two cards overlap, and the percentage of overlap
      // e.g. if the card is overlapping two drop points, choose the one with the greater overlap
      const touchedStack = ({x, y}) => {
        return stacks.findIndex(stack => {
          return x > stack.x &&
            x < stack.x + cardWidth &&
            y > stack.y &&
            y < stack.y + cardHeight;
        });
      };

      // TODO: hardcoded for a single card
      const touchedCard = (point, card) => {
        return false;
        return point.x > card.x &&
            point.x < card.x + cardWidth &&
            point.y > card.y &&
            point.y < card.y + cardHeight;
      };

      const getCoords = event => {
        // need to scale the touches by the actual size of the canvas;
        // e.g. the canvas still thinks it is 605px wide even if it is
        // scaled to 400px by CSS rules
        const scale = event.target.width / event.target.clientWidth;

        if (event.changedTouches && event.changedTouches.length > 0) {
          return {
            x: event.changedTouches[0].clientX * scale,
            y: event.changedTouches[0].clientY * scale
          };
        }

        // this seems to translate to <canvas> coordinates
        return {
          x: event.x - event.target.offsetLeft,
          y: event.y - event.target.offsetTop
        }
      };

      const onDown = e => {
        e.preventDefault();

        let {x, y} = getCoords(e);

        if (touchedCard({x, y})) {
          canvas.style.cursor = 'grabbing';
          grabbed = card;
          grabOffset = {
            x: x - card.x,
            y: y - card.y
          };
        }
      };

      const onMove = e => {
        e.preventDefault();

        if (!grabbed) {
          return;
        }

        let {x, y} = getCoords(e);

        // move the card along with the touch/cursor
        grabbed.x = x - grabOffset.x;
        grabbed.y = y - grabOffset.y;

        update();
      };

      const onUp = e => {
        e.preventDefault();

        let {x, y} = getCoords(e);

        // if touched the draw pile
        if (touchedStack({x, y}) === 0) {
          // flip the topmost card over
          let card = DECK.shift();
          card.faceUp = true;

          update();

          return;
        }

        if (!grabbed) {
          return;
        }

        canvas.style.cursor = 'grab';

        // TODO: check if current position of card overlaps any of the drop zones
        // if so, lock to that location
        const stackIndex = touchedStack({x, y});
        if (stackIndex !== -1) {
          grabbed.x = stacks[stackIndex].x;
          grabbed.y = stacks[stackIndex].y;
        } else {
          // otherwise, move the card back to its original position
          // TEMP: just return card back to the "draw" pile
          grabbed.x = stacks[0].x;
          grabbed.y = stacks[0].y;
        }

        // "release" reference to card
        grabbed = null;

        update();
      };

      canvas.addEventListener('mousedown', onDown);
      canvas.addEventListener('mousemove', onMove);
      canvas.addEventListener('mouseup', onUp);

      canvas.addEventListener('touchstart', onDown);
      canvas.addEventListener('touchmove', onMove);
      canvas.addEventListener('touchend', onUp);
    };

    const target = new Image();
    target.src = 'images/target.png';
  </script>
</head>
<body>
  <canvas id="game" width="605" height="454"></canvas>
</body>
</html>
