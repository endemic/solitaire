<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Dragging Demo</title>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body { text-align: center; }

    #game {
      margin: auto;
      background-color: #0a5;
      max-width: 100%;
      max-height: 100%;
      /* TODO: this doesn't seem to work on an actual phone */
      aspect-ratio: 4 / 3;
      cursor: grab;
    }
  </style>

<script src="scripts/shuffle.js"></script>
<script src="scripts/card.js"></script>

  <script>
    const SUITES = ['hearts', 'diamonds', 'spades', 'clubs'];
    const RANKS = ['ace', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'jack', 'queen', 'king'];

    const IMG_SRC = [
      'images/backs/one.png',
      'images/backs/target.png',

      // 'images/hearts/ace.png',
      // 'images/hearts/two.png',
      // 'images/hearts/three.png',
      'images/hearts/four.png',
      // 'images/hearts/five.png',
      // 'images/hearts/six.png',
      // 'images/hearts/seven.png',
      // 'images/hearts/eight.png',
      // 'images/hearts/nine.png',
      // 'images/hearts/ten.png',
      // 'images/hearts/jack.png',
      // 'images/hearts/queen.png',
      // 'images/hearts/king.png',

      // 'images/diamonds/ace.png',
      'images/diamonds/two.png',
      'images/diamonds/three.png',
      // 'images/diamonds/four.png',
      // 'images/diamonds/five.png',
      // 'images/diamonds/six.png',
      // 'images/diamonds/seven.png',
      // 'images/diamonds/eight.png',
      // 'images/diamonds/nine.png',
      'images/diamonds/ten.png',
      // 'images/diamonds/jack.png',
      // 'images/diamonds/queen.png',
      // 'images/diamonds/king.png',

      // 'images/spades/ace.png',
      'images/spades/two.png',
      // 'images/spades/three.png',
      // 'images/spades/four.png',
      // 'images/spades/five.png',
      // 'images/spades/six.png',
      // 'images/spades/seven.png',
      // 'images/spades/eight.png',
      // 'images/spades/nine.png',
      // 'images/spades/ten.png',
      // 'images/spades/jack.png',
      // 'images/spades/queen.png',
      // 'images/spades/king.png',

      // 'images/clubs/ace.png',
      'images/clubs/two.png',
      // 'images/clubs/three.png',
      // 'images/clubs/four.png',
      'images/clubs/five.png',
      // 'images/clubs/six.png',
      // 'images/clubs/seven.png',
      // 'images/clubs/eight.png',
      // 'images/clubs/nine.png',
      // 'images/clubs/ten.png',
      // 'images/clubs/jack.png',
      // 'images/clubs/queen.png',
      // 'images/clubs/king.png',
    ];

    const IMAGES = {};
    let loadedImageCount = 0;

    const onImageLoad = e => {
      // TODO: display a progress bar or something
      loadedImageCount += 1;

      // this means we've got all our images in memory
      if (loadedImageCount === IMG_SRC.length) {
        // TODO: initialize the canvas before this, so a "loading" progress bar can be
        // displayed (or "Loading..." text)
        dragDemo();
      }
    }

    // enumerate over image sources, and load them into memory
    IMG_SRC.forEach(src => {
      // key is in format `suite_rank` -- probably a better way to do this
      let key = src.match(/(?<=images\/)\w+\/\w+/)[0].replace('/','_');

      IMAGES[key] = new Image();
      IMAGES[key].src = src;
      IMAGES[key].addEventListener('load', onImageLoad);
    });



    const dragDemo = e => {
      const canvas = document.getElementById('game');
      const context = canvas.getContext('2d');

      // TODO: determine the necessary max width/height based on screenshots of the old game
      // cards are 71x96px
      // margin between cards horizontally is 16px
      // margin between cards vertically is 6px

      // we could do 75x100px cards
      // 10px margin both horizontally & vertically
      // 525px total width of all cards
      // 80px (8 * 10px) horizontal margin

      // 605px max width
      // at 4:3 aspect ratio, that makes height 454px
      // is that a viable size?

      const margin = 10;
      const width = 605;
      const height = 454;
      const cardWidth = 75;
      const cardHeight = 100;

      // initialize all places where a card can be placed - https://en.wikipedia.org/wiki/Glossary_of_patience_terms

      // "talon" (draw pile)
      // placed in the upper left hand corner
      let talon = {
        x: margin,
        y: margin,
        cards: []
      };

      // "waste" (play stack)
      // placed relative to the talon
      let waste = {
        x: talon.x + cardWidth + margin,
        y: talon.y,
        cards: []
      };

      // 4 "foundations"
      // aligned vertically with talon/waste, on right side of tableau
      let foundations = [];
      for (let i = 0; i < 4; i += 1) {
        foundations.push({
          x: width - (cardWidth * (i + 1)) - (margin * (i + 1)),
          y: margin,
          cards: []
        });
      }

      // 7 "piles"
      // spans the width of the tableau, under the talon/waste/foundations
      let piles = [];
      for (let i = 0; i < 7; i += 1) {
        piles.push({
          x: cardWidth * i + (margin * (i + 1)),
          y: cardHeight + margin * 2,
          cards: []
        });
      }

      // initialize deck
      // SUITES.forEach(suite => {
      //   RANKS.forEach(rank => {
      //     let card = new Card(rank, suite, IMAGES);

      //     // put all cards face down in the talon
      //     card.x = talon.x;
      //     card.y = talon.y;

      //     talon.cards.push(card);
      //   });
      // });

      // TODO: until card front images are complete
      [
        ['two', 'clubs'],
        ['five', 'clubs'],
        ['ten', 'diamonds'],
        ['three', 'diamonds'],
        ['two', 'diamonds'],
        ['two', 'spades'],
        ['four', 'hearts']
      ].forEach(pair => {
        let tmp = new Card(pair[0], pair[1], IMAGES);
        tmp.x = talon.x;
        tmp.y = talon.y;
        talon.cards.push(tmp);
      });

      talon.cards.shuffle();

      const update = () => {
        // clear previous contents
        context.clearRect(0, 0, width, height);

        drawTalon();

        drawWaste();

        foundations.forEach(f => drawFoundation(f));

        piles.forEach(p => drawPile(p));

        drawGrabbed();
      };

      const drawTalon = () => {
        if (talon.cards.length === 0) {
          context.drawImage(IMAGES['backs_target'], talon.x, talon.y);

          return;
        }

        // we only need to draw the "top-most" card (which is the last in the array)
        context.drawImage(talon.cards[talon.cards.length - 1].image, talon.x, talon.y);
      };

      const drawWaste = () => {
        if (waste.cards.length === 0) {
          context.drawImage(IMAGES['backs_target'], waste.x, waste.y);

          return;
        }

        // only need to draw the first card
        // TODO: with three card draw, we'll have to draw 3 cards offset
        context.drawImage(waste.cards[0].image, waste.x, waste.y);
      };

      const drawFoundation = f => {
        if (f.cards.length === 0) {
          context.drawImage(IMAGES['backs_target'], f.x, f.y);

          return;
        }

        // only draw the top-most card
        context.drawImage(f.cards[f.cards.length - 1].image, f.x, f.y);
      };

      const drawPile = p => {
        if (p.cards.length === 0) {
          context.drawImage(IMAGES['backs_target'], p.x, p.y);

          return;
        }

        // only draw the top-most card
        // TODO: need to draw these stacks in an offset way, such that
        // we can see each card in the stack;
        // implementation idea: set the card positions on each draw call
        // that way I don't have to set those values when the card is dropped
        context.drawImage(p.cards[p.cards.length - 1].image, p.x, p.y);
      };

      const drawGrabbed = () => {
        if (!grabbed) {
          return;
        }

        context.drawImage(grabbed.image, grabbed.x, grabbed.y);
      };

      // bool whether a card has been picked up or not
      let grabbed = null;

      // record the cursor offset where the card was picked up,
      // so clicking the card doesn't cause it to "jump" to the cursor
      let grabOffset = {x: 0, y: 0};

      // initial draw
      update();

      // rudimentary bounding box intersection
      // TODO: make this a check to see if two cards overlap, and the percentage of overlap
      // e.g. if the card is overlapping two drop points, choose the one with the greater overlap
      const touchedStack = ({x, y}) => {
        return stacks.findIndex(stack => {
          return x > stack.x &&
            x < stack.x + cardWidth &&
            y > stack.y &&
            y < stack.y + cardHeight;
        });
      };

      //
      const touchedCard = (point, card) => {
        return point.x > card.x &&
            point.x < card.x + cardWidth &&
            point.y > card.y &&
            point.y < card.y + cardHeight;
      };

      const getCoords = event => {
        // need to scale the touches by the actual size of the canvas;
        // e.g. the canvas still thinks it is 605px wide even if it is
        // scaled to 400px by CSS rules
        const scale = event.target.width / event.target.clientWidth;

        if (event.changedTouches && event.changedTouches.length > 0) {
          return {
            x: event.changedTouches[0].clientX * scale,
            y: event.changedTouches[0].clientY * scale
          };
        }

        // this seems to translate to <canvas> coordinates
        return {
          x: event.x - event.target.offsetLeft,
          y: event.y - event.target.offsetTop
        }
      };

      const onDown = e => {
        e.preventDefault();

        let point = getCoords(e);

        // if player clicks the talon
        if (touchedCard(point, talon)) {
          // and there are still cards left
          if (talon.cards.length > 0) {
            // flip one over onto the waste pile
            let card = talon.cards.pop();
            card.faceUp = true;
            card.x = waste.x;
            card.y = waste.y;
            waste.cards.unshift(card);
          } else {
            // otherwise, move the waste back onto the talon
            talon.cards = waste.cards.map(c => {
              c.faceUp = false;
              return c;
            }).reverse();
            waste.cards = [];
          }
        }

        // if player clicks the waste pile
        // "grab" the top-most card
        if (touchedCard(point, waste)) {
          canvas.style.cursor = 'grabbing';

          grabbed = waste.cards.shift();
          grabOffset = {
            x: point.x - grabbed.x,
            y: point.y - grabbed.y
          };
        }

        // TODO: allow player to pick cards back up off the foundations
        // "parent" card for the first card in the foundation pile will
        // probably be the foundation itself?

        // TODO: allow player to pick up cards from piles
        // check collision detection against visible card fragments, as well
        // as the entire card on top of the pile

        update();
      };

      const onMove = e => {
        e.preventDefault();

        if (!grabbed) {
          return;
        }

        let {x, y} = getCoords(e);

        // move the card along with the touch/cursor
        grabbed.x = x - grabOffset.x;
        grabbed.y = y - grabOffset.y;

        update();
      };

      const onUp = e => {
        e.preventDefault();

        let point = getCoords(e);

        // if not holding a card, then there's nothing to do
        if (!grabbed) {
          return;
        }

        canvas.style.cursor = 'grab';

        // check if current position of card overlaps
        // any playable area; if so, move to that location

        let valid = false;

        // check foundations
        foundations.forEach(f => {
          if (touchedCard(point, f)) {
            valid = true;

            f.cards.push(grabbed);

            // this sets the parent/child of the card stack
            // not sure it is necessary to have both the card array of the stack
            // as well as the "linked list"
            if (f.cards.length === 0) {
              grabbed.parent = f;
            } else {
              let newParent = f.cards[f.cards.length - 1];
              newParent.child = grabbed;
              grabbed.parent = newParent;
            }
          }
        });

        // check piles
        piles.forEach(p => {
          if (touchedCard(point, p)) {
            valid = true;

            p.cards.push(grabbed);

            // this sets the parent/child of the card stack
            // not sure it is necessary to have both the card array of the stack
            // as well as the "linked list"
            if (p.cards.length === 0) {
              grabbed.parent = p;
            } else {
              let newParent = p.cards[p.cards.length - 1];
              newParent.child = grabbed;
              grabbed.parent = newParent;
            }
          }
        });

        // if no valid play was made
        if (!valid) {
          // put the card back where it was
          // TODO: how to store the previous location?
          grabbed.x = waste.x;
          grabbed.y = waste.y;
          waste.cards.unshift(grabbed);
        }

        // "release" reference to card
        grabbed = null;

        update();
      };

      canvas.addEventListener('mousedown', onDown);
      canvas.addEventListener('mousemove', onMove);
      canvas.addEventListener('mouseup', onUp);

      canvas.addEventListener('touchstart', onDown);
      canvas.addEventListener('touchmove', onMove);
      canvas.addEventListener('touchend', onUp);
    };
  </script>
</head>
<body>
  <canvas id="game" width="605" height="454"></canvas>
</body>
</html>
